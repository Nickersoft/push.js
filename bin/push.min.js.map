{"version":3,"file":"push.min.js","sources":["../src/push/Messages.js","../src/push/Permission.js","../src/push/Util.js","../src/agents/AbstractAgent.js","../src/agents/DesktopAgent.js","../src/agents/MobileChromeAgent.js","../src/agents/MobileFirefoxAgent.js","../src/agents/MSAgent.js","../src/agents/WebKitAgent.js","../src/index.js","../src/push/Push.js"],"sourcesContent":["// @flow\nconst errorPrefix = 'PushError:';\n\nexport default {\n    errors: {\n        incompatible: `${errorPrefix} Push.js is incompatible with browser.`,\n        invalid_plugin: `${errorPrefix} plugin class missing from plugin manifest (invalid plugin). Please check the documentation.`,\n        invalid_title: `${errorPrefix} title of notification must be a string`,\n        permission_denied: `${errorPrefix} permission request declined`,\n        sw_notification_error: `${errorPrefix} could not show a ServiceWorker notification due to the following reason: `,\n        sw_registration_error: `${errorPrefix} could not register the ServiceWorker due to the following reason: `,\n        unknown_interface: `${errorPrefix} unable to create notification: unknown interface`\n    }\n};\n","// @flow\nimport type { Global } from 'types';\n\nexport default class Permission {\n    // Private members\n    _permissions: string[];\n    _win: Global;\n\n    // Public members\n    GRANTED: string;\n    DEFAULT: string;\n    DENIED: string;\n\n    constructor(win: Global) {\n        this._win = win;\n        this.GRANTED = 'granted';\n        this.DEFAULT = 'default';\n        this.DENIED = 'denied';\n        this._permissions = [this.GRANTED, this.DEFAULT, this.DENIED];\n    }\n\n    /**\n   * Requests permission for desktop notifications\n   * @param {Function} onGranted - Function to execute once permission is granted\n   * @param {Function} onDenied - Function to execute once permission is denied\n   * @return {void, Promise}\n   */\n    request(onGranted: () => void, onDenied: () => void) {\n        return arguments.length > 0\n            ? this._requestWithCallback(...arguments)\n            : this._requestAsPromise();\n    }\n\n    /**\n   * Old permissions implementation deprecated in favor of a promise based one\n   * @deprecated Since V1.0.4\n   * @param {Function} onGranted - Function to execute once permission is granted\n   * @param {Function} onDenied - Function to execute once permission is denied\n   * @return {void}\n   */\n    _requestWithCallback(onGranted: () => void, onDenied: () => void) {\n        const existing = this.get();\n\n        var resolve = (result = this._win.Notification.permission) => {\n            if (typeof result === 'undefined' && this._win.webkitNotifications)\n                result = this._win.webkitNotifications.checkPermission();\n            if (result === this.GRANTED || result === 0) {\n                if (onGranted) onGranted();\n            } else if (onDenied) onDenied();\n        };\n\n        /* Permissions already set */\n        if (existing !== this.DEFAULT) {\n            resolve(existing);\n        } else if (\n            this._win.webkitNotifications &&\n            this._win.webkitNotifications.checkPermission\n        ) {\n            /* Safari 6+, Legacy webkit browsers */\n            this._win.webkitNotifications.requestPermission(resolve);\n        } else if (\n            this._win.Notification &&\n            this._win.Notification.requestPermission\n        ) {\n            /* Chrome 23+ */\n            this._win.Notification\n                .requestPermission()\n                .then(resolve)\n                .catch(function() {\n                    if (onDenied) onDenied();\n                });\n        } else if (onGranted) {\n            /* Let the user continue by default */\n            onGranted();\n        }\n    }\n\n    /**\n   * Requests permission for desktop notifications in a promise based way\n   * @return {Promise}\n   */\n    _requestAsPromise(): Promise<void> {\n        const existing = this.get();\n\n        let isGranted = result => result === this.GRANTED || result === 0;\n\n        /* Permissions already set */\n        var hasPermissions = existing !== this.DEFAULT;\n\n        /* Safari 6+, Chrome 23+ */\n        var isModernAPI =\n            this._win.Notification && this._win.Notification.requestPermission;\n\n        /* Legacy webkit browsers */\n        var isWebkitAPI =\n            this._win.webkitNotifications &&\n            this._win.webkitNotifications.checkPermission;\n\n        return new Promise((resolvePromise, rejectPromise) => {\n            var resolver = result =>\n                isGranted(result) ? resolvePromise() : rejectPromise();\n\n            if (hasPermissions) {\n                resolver(existing);\n            } else if (isWebkitAPI) {\n                this._win.webkitNotifications.requestPermission(result => {\n                    resolver(result);\n                });\n            } else if (isModernAPI) {\n                this._win.Notification\n                    .requestPermission()\n                    .then(result => {\n                        resolver(result);\n                    })\n                    .catch(rejectPromise);\n            } else resolvePromise();\n        });\n    }\n\n    /**\n   * Returns whether Push has been granted permission to run\n   * @return {Boolean}\n   */\n    has() {\n        return this.get() === this.GRANTED;\n    }\n\n    /**\n   * Gets the permission level\n   * @return {Permission} The permission level\n   */\n    get() {\n        let permission;\n\n        /* Safari 6+, Chrome 23+ */\n        if (this._win.Notification && this._win.Notification.permission)\n            permission = this._win.Notification.permission;\n        else if (\n            this._win.webkitNotifications &&\n            this._win.webkitNotifications.checkPermission\n        )\n            /* Legacy webkit browsers */\n            permission = this._permissions[\n                this._win.webkitNotifications.checkPermission()\n            ];\n        else if (navigator.mozNotification)\n            /* Firefox Mobile */\n            permission = this.GRANTED;\n        else if (this._win.external && this._win.external.msIsSiteMode)\n            /* IE9+ */\n            permission = this._win.external.msIsSiteMode()\n                ? this.GRANTED\n                : this.DEFAULT;\n        else permission = this.GRANTED;\n\n        return permission;\n    }\n}\n","// @flow\nexport default class Util {\n    static isUndefined(obj) {\n        return obj === undefined;\n    }\n\n    static isString(obj) {\n        return typeof obj === 'string';\n    }\n\n    static isFunction(obj) {\n        return obj && {}.toString.call(obj) === '[object Function]';\n    }\n\n    static isObject(obj) {\n        return typeof obj === 'object';\n    }\n\n    static objectMerge(target, source) {\n        for (var key in source) {\n            if (\n                target.hasOwnProperty(key) &&\n                this.isObject(target[key]) &&\n                this.isObject(source[key])\n            ) {\n                this.objectMerge(target[key], source[key]);\n            } else {\n                target[key] = source[key];\n            }\n        }\n    }\n}\n","// @flow\nimport type { Global } from 'types';\n\nexport default class AbstractAgent {\n    _win: Global;\n\n    constructor(win: Global) {\n        this._win = win;\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport { Util } from 'push';\nimport type { PushOptions, GenericNotification, Global } from 'types';\n\n/**\n * Notification agent for modern desktop browsers:\n * Safari 6+, Firefox 22+, Chrome 22+, Opera 25+\n */\nexport default class DesktopAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return this._win.Notification !== undefined;\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        return new this._win.Notification(title, {\n            icon:\n                Util.isString(options.icon) || Util.isUndefined(options.icon)\n                    ? options.icon\n                    : options.icon.x32,\n            body: options.body,\n            tag: options.tag,\n            requireInteraction: options.requireInteraction\n        });\n    }\n\n    /**\n     * Close a given notification\n     * @param notification - notification to close\n     */\n    close(notification: GenericNotification) {\n        notification.close();\n    }\n}\n","// @flow\nimport { Util, Messages } from 'push';\nimport { AbstractAgent } from 'agents';\nimport type { Global, GenericNotification, PushOptions } from 'types';\n\n/**\n * Notification agent for modern desktop browsers:\n * Safari 6+, Firefox 22+, Chrome 22+, Opera 25+\n */\nexport default class MobileChromeAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return (\n            this._win.navigator !== undefined &&\n            this._win.navigator.serviceWorker !== undefined\n        );\n    }\n\n    /**\n     * Returns the function body as a string\n     * @param func\n     */\n    getFunctionBody(func: () => void) {\n        const str = func.toString().match(/function[^{]+{([\\s\\S]*)}$/);\n        return typeof str !== 'undefined' && str !== null && str.length > 1\n            ? str[1]\n            : null;\n    }\n\n    /**\n     * Creates a new notification\n     * @param id                ID of notification\n     * @param title             Title of notification\n     * @param options           Options object\n     * @param serviceWorker     ServiceWorker path\n     * @param callback          Callback function\n     */\n    create(\n        id: number,\n        title: string,\n        options: PushOptions,\n        serviceWorker: string,\n        callback: (GenericNotification[]) => void\n    ) {\n        /* Register ServiceWorker */\n        this._win.navigator.serviceWorker.register(serviceWorker);\n\n        this._win.navigator.serviceWorker.ready\n            .then(registration => {\n                /* Local data the service worker will use */\n                let localData = {\n                    id: id,\n                    link: options.link,\n                    origin: document.location.href,\n                    onClick: Util.isFunction(options.onClick)\n                        ? this.getFunctionBody(options.onClick)\n                        : '',\n                    onClose: Util.isFunction(options.onClose)\n                        ? this.getFunctionBody(options.onClose)\n                        : ''\n                };\n\n                /* Merge the local data with user-provided data */\n                if (options.data !== undefined && options.data !== null)\n                    localData = Object.assign(localData, options.data);\n\n                /* Show the notification */\n                registration\n                    .showNotification(title, {\n                        icon: options.icon,\n                        body: options.body,\n                        vibrate: options.vibrate,\n                        tag: options.tag,\n                        data: localData,\n                        requireInteraction: options.requireInteraction,\n                        silent: options.silent\n                    })\n                    .then(() => {\n                        registration.getNotifications().then(notifications => {\n                            /* Send an empty message so the ServiceWorker knows who the client is */\n                            registration.active.postMessage('');\n\n                            /* Trigger callback */\n                            callback(notifications);\n                        });\n                    })\n                    .catch(function(error) {\n                        throw new Error(\n                            Messages.errors.sw_notification_error +\n                                error.message\n                        );\n                    });\n            })\n            .catch(function(error) {\n                throw new Error(\n                    Messages.errors.sw_registration_error + error.message\n                );\n            });\n    }\n\n    /**\n     * Close all notification\n     */\n    close() {\n        // Can't do this with service workers\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport type { Global, PushOptions } from 'types';\n\n/**\n * Notification agent for modern desktop browsers:\n * Safari 6+, Firefox 22+, Chrome 22+, Opera 25+\n */\nexport default class MobileFirefoxAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return this._win.navigator.mozNotification !== undefined;\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        let notification = this._win.navigator.mozNotification.createNotification(\n            title,\n            options.body,\n            options.icon\n        );\n\n        notification.show();\n\n        return notification;\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport { Util } from 'push';\nimport type { PushOptions, Global } from 'types';\n\n/**\n * Notification agent for IE9\n */\nexport default class MSAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return (\n            this._win.external !== undefined &&\n            this._win.external.msIsSiteMode !== undefined\n        );\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        /* Clear any previous notifications */\n        this._win.external.msSiteModeClearIconOverlay();\n\n        this._win.external.msSiteModeSetIconOverlay(\n            Util.isString(options.icon) || Util.isUndefined(options.icon)\n                ? options.icon\n                : options.icon.x16,\n            title\n        );\n\n        this._win.external.msSiteModeActivate();\n\n        return null;\n    }\n\n    /**\n     * Close a given notification\n     * @param notification - notification to close\n     */\n    close() {\n        this._win.external.msSiteModeClearIconOverlay();\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport type { Global, GenericNotification, PushOptions } from 'types';\n\n/**\n * Notification agent for old Chrome versions (and some) Firefox\n */\nexport default class WebKitAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return this._win.webkitNotifications !== undefined;\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        let notification = this._win.webkitNotifications.createNotification(\n            options.icon,\n            title,\n            options.body\n        );\n\n        notification.show();\n\n        return notification;\n    }\n\n    /**\n     * Close a given notification\n     * @param notification - notification to close\n     */\n    close(notification: GenericNotification) {\n        notification.cancel();\n    }\n}\n","// @flow\nimport { Push } from 'push';\n\nexport default new Push(typeof window !== 'undefined' ? window : global);\n","// @flow\nimport { Messages, Permission, Util } from 'push';\nimport type { PluginManifest, GenericNotification, PushOptions } from 'types';\n\n/* Import notification agents */\nimport {\n    DesktopAgent,\n    MobileChromeAgent,\n    MobileFirefoxAgent,\n    MSAgent,\n    WebKitAgent\n} from 'agents';\n\nexport default class Push {\n    // Private members\n    _agents: {\n        desktop: DesktopAgent,\n        chrome: MobileChromeAgent,\n        firefox: MobileFirefoxAgent,\n        ms: MSAgent,\n        webkit: WebKitAgent\n    };\n    _configuration: {\n        serviceWorker: string,\n        fallback: ({}) => void\n    };\n    _currentId: number;\n    _notifications: {};\n    _win: {};\n\n    // Public members\n    Permission: Permission;\n\n    constructor(win: {}) {\n        /* Private variables */\n\n        /* ID to use for new notifications */\n        this._currentId = 0;\n\n        /* Map of open notifications */\n        this._notifications = {};\n\n        /* Window object */\n        this._win = win;\n\n        /* Public variables */\n        this.Permission = new Permission(win);\n\n        /* Agents */\n        this._agents = {\n            desktop: new DesktopAgent(win),\n            chrome: new MobileChromeAgent(win),\n            firefox: new MobileFirefoxAgent(win),\n            ms: new MSAgent(win),\n            webkit: new WebKitAgent(win)\n        };\n\n        this._configuration = {\n            serviceWorker: '/serviceWorker.min.js',\n            fallback: function(payload) {}\n        };\n    }\n\n    /**\n     * Closes a notification\n     * @param id            ID of notification\n     * @returns {boolean}   denotes whether the operation was successful\n     * @private\n     */\n    _closeNotification(id: number | string) {\n        let success = true;\n        const notification = this._notifications[id];\n\n        if (notification !== undefined) {\n            success = this._removeNotification(id);\n\n            /* Safari 6+, Firefox 22+, Chrome 22+, Opera 25+ */\n            if (this._agents.desktop.isSupported())\n                this._agents.desktop.close(notification);\n            else if (this._agents.webkit.isSupported())\n                /* Legacy WebKit browsers */\n                this._agents.webkit.close(notification);\n            else if (this._agents.ms.isSupported())\n                /* IE9 */\n                this._agents.ms.close();\n            else {\n                success = false;\n                throw new Error(Messages.errors.unknown_interface);\n            }\n\n            return success;\n        }\n\n        return false;\n    }\n\n    /**\n   * Adds a notification to the global dictionary of notifications\n   * @param {Notification} notification\n   * @return {Integer} Dictionary key of the notification\n   * @private\n   */\n    _addNotification(notification: GenericNotification) {\n        const id = this._currentId;\n        this._notifications[id] = notification;\n        this._currentId++;\n        return id;\n    }\n\n    /**\n   * Removes a notification with the given ID\n   * @param  {Integer} id - Dictionary key/ID of the notification to remove\n   * @return {Boolean} boolean denoting success\n   * @private\n   */\n    _removeNotification(id: number | string) {\n        let success = false;\n\n        if (this._notifications.hasOwnProperty(id)) {\n            /* We're successful if we omit the given ID from the new array */\n            delete this._notifications[id];\n            success = true;\n        }\n\n        return success;\n    }\n\n    /**\n   * Creates the wrapper for a given notification\n   *\n   * @param {Integer} id - Dictionary key/ID of the notification\n   * @param {Map} options - Options used to create the notification\n   * @returns {Map} wrapper hashmap object\n   * @private\n   */\n    _prepareNotification(id: number, options: PushOptions) {\n        let wrapper;\n\n        /* Wrapper used to get/close notification later on */\n        wrapper = {\n            get: () => {\n                return this._notifications[id];\n            },\n\n            close: () => {\n                this._closeNotification(id);\n            }\n        };\n\n        /* Autoclose timeout */\n        if (options.timeout) {\n            setTimeout(() => {\n                wrapper.close();\n            }, options.timeout);\n        }\n\n        return wrapper;\n    }\n\n    /**\n   * Find the most recent notification from a ServiceWorker and add it to the global array\n   * @param notifications\n   * @private\n   */\n    _serviceWorkerCallback(\n        notifications: GenericNotification[],\n        options: PushOptions,\n        resolve: ({} | null) => void\n    ) {\n        let id = this._addNotification(notifications[notifications.length - 1]);\n\n        /* Listen for close requests from the ServiceWorker */\n        if (navigator && navigator.serviceWorker) {\n            navigator.serviceWorker.addEventListener('message', event => {\n                const data = JSON.parse(event.data);\n\n                if (data.action === 'close' && Number.isInteger(data.id))\n                    this._removeNotification(data.id);\n            });\n\n            resolve(this._prepareNotification(id, options));\n        }\n\n        resolve(null);\n    }\n\n    /**\n   * Callback function for the 'create' method\n   * @return {void}\n   * @private\n   */\n    _createCallback(\n        title: string,\n        options: PushOptions,\n        resolve: ({} | null) => void\n    ) {\n        let notification = null;\n        let onClose;\n\n        /* Set empty settings if none are specified */\n        options = options || {};\n\n        /* onClose event handler */\n        onClose = id => {\n            /* A bit redundant, but covers the cases when close() isn't explicitly called */\n            this._removeNotification(id);\n            if (Util.isFunction(options.onClose)) {\n                options.onClose.call(this, notification);\n            }\n        };\n\n        /* Safari 6+, Firefox 22+, Chrome 22+, Opera 25+ */\n        if (this._agents.desktop.isSupported()) {\n            try {\n                /* Create a notification using the API if possible */\n                notification = this._agents.desktop.create(title, options);\n            } catch (e) {\n                const id = this._currentId;\n                const sw = this.config().serviceWorker;\n                const cb = notifications =>\n                    this._serviceWorkerCallback(\n                        notifications,\n                        options,\n                        resolve\n                    );\n                /* Create a Chrome ServiceWorker notification if it isn't supported */\n                if (this._agents.chrome.isSupported()) {\n                    this._agents.chrome.create(id, title, options, sw, cb);\n                }\n            }\n            /* Legacy WebKit browsers */\n        } else if (this._agents.webkit.isSupported())\n            notification = this._agents.webkit.create(title, options);\n        else if (this._agents.firefox.isSupported())\n            /* Firefox Mobile */\n            this._agents.firefox.create(title, options);\n        else if (this._agents.ms.isSupported())\n            /* IE9 */\n            notification = this._agents.ms.create(title, options);\n        else {\n            /* Default fallback */\n            options.title = title;\n            this.config().fallback(options);\n        }\n\n        if (notification !== null) {\n            const id = this._addNotification(notification);\n            const wrapper = this._prepareNotification(id, options);\n\n            /* Notification callbacks */\n            if (Util.isFunction(options.onShow))\n                notification.addEventListener('show', options.onShow);\n\n            if (Util.isFunction(options.onError))\n                notification.addEventListener('error', options.onError);\n\n            if (Util.isFunction(options.onClick))\n                notification.addEventListener('click', options.onClick);\n\n            notification.addEventListener('close', () => {\n                onClose(id);\n            });\n\n            notification.addEventListener('cancel', () => {\n                onClose(id);\n            });\n\n            /* Return the wrapper so the user can call close() */\n            resolve(wrapper);\n        }\n\n        /* By default, pass an empty wrapper */\n        resolve(null);\n    }\n\n    /**\n   * Creates and displays a new notification\n   * @param {Array} options\n   * @return {Promise}\n   */\n    create(title: string, options: {}): Promise<void> {\n        let promiseCallback;\n\n        /* Fail if no or an invalid title is provided */\n        if (!Util.isString(title)) {\n            throw new Error(Messages.errors.invalid_title);\n        }\n\n        /* Request permission if it isn't granted */\n        if (!this.Permission.has()) {\n            promiseCallback = (resolve: () => void, reject: string => void) => {\n                this.Permission\n                    .request()\n                    .then(() => {\n                        this._createCallback(title, options, resolve);\n                    })\n                    .catch(() => {\n                        reject(Messages.errors.permission_denied);\n                    });\n            };\n        } else {\n            promiseCallback = (resolve: () => void, reject: string => void) => {\n                try {\n                    this._createCallback(title, options, resolve);\n                } catch (e) {\n                    reject(e);\n                }\n            };\n        }\n\n        return new Promise(promiseCallback);\n    }\n\n    /**\n   * Returns the notification count\n   * @return {Integer} The notification count\n   */\n    count() {\n        let count = 0;\n        let key;\n\n        for (key in this._notifications)\n            if (this._notifications.hasOwnProperty(key)) count++;\n\n        return count;\n    }\n\n    /**\n   * Closes a notification with the given tag\n   * @param {String} tag - Tag of the notification to close\n   * @return {Boolean} boolean denoting success\n   */\n    close(tag: string) {\n        let key, notification;\n\n        for (key in this._notifications) {\n            if (this._notifications.hasOwnProperty(key)) {\n                notification = this._notifications[key];\n\n                /* Run only if the tags match */\n                if (notification.tag === tag) {\n                    /* Call the notification's close() method */\n                    return this._closeNotification(key);\n                }\n            }\n        }\n    }\n\n    /**\n   * Clears all notifications\n   * @return {Boolean} boolean denoting whether the clear was successful in closing all notifications\n   */\n    clear() {\n        let key,\n            success = true;\n\n        for (key in this._notifications)\n            if (this._notifications.hasOwnProperty(key))\n                success = success && this._closeNotification(key);\n\n        return success;\n    }\n\n    /**\n   * Denotes whether Push is supported in the current browser\n   * @returns {boolean}\n   */\n    supported() {\n        let supported = false;\n\n        for (var agent in this._agents)\n            if (this._agents.hasOwnProperty(agent))\n                supported = supported || this._agents[agent].isSupported();\n\n        return supported;\n    }\n\n    /**\n   * Modifies settings or returns all settings if no parameter passed\n   * @param settings\n   */\n    config(settings?: {}) {\n        if (\n            typeof settings !== 'undefined' ||\n            (settings !== null && Util.isObject(settings))\n        )\n            Util.objectMerge(this._configuration, settings);\n\n        return this._configuration;\n    }\n\n    /**\n   * Copies the functions from a plugin to the main library\n   * @param plugin\n   */\n    extend(manifest: PluginManifest) {\n        var plugin,\n            Plugin,\n            hasProp = {}.hasOwnProperty;\n\n        if (!hasProp.call(manifest, 'plugin')) {\n            throw new Error(Messages.errors.invalid_plugin);\n        } else {\n            if (\n                hasProp.call(manifest, 'config') &&\n                Util.isObject(manifest.config) &&\n                manifest.config !== null\n            ) {\n                this.config(manifest.config);\n            }\n\n            Plugin = manifest.plugin;\n            plugin = new Plugin(this.config());\n\n            for (var member in plugin) {\n                if (\n                    hasProp.call(plugin, member) &&\n                    Util.isFunction(plugin[member])\n                )\n                    // $FlowFixMe\n                    this[member] = plugin[member];\n            }\n        }\n    }\n}\n"],"names":["errorPrefix","Permission","win","_win","GRANTED","DEFAULT","DENIED","_permissions","this","onGranted","onDenied","arguments","length","_requestWithCallback","_requestAsPromise","existing","get","resolve","result","_this","Notification","permission","webkitNotifications","checkPermission","requestPermission","then","catch","isGranted","_this2","hasPermissions","isModernAPI","isWebkitAPI","Promise","resolvePromise","rejectPromise","resolver","navigator","mozNotification","external","msIsSiteMode","Util","obj","undefined","toString","call","target","source","key","hasOwnProperty","isObject","objectMerge","AbstractAgent","DesktopAgent","title","options","isString","icon","isUndefined","x32","body","tag","requireInteraction","notification","close","MobileChromeAgent","serviceWorker","func","str","match","id","callback","register","ready","localData","link","document","location","href","isFunction","onClick","getFunctionBody","onClose","data","Object","assign","showNotification","vibrate","silent","getNotifications","active","postMessage","notifications","error","Error","Messages","errors","sw_notification_error","message","sw_registration_error","MobileFirefoxAgent","createNotification","show","MSAgent","msSiteModeClearIconOverlay","msSiteModeSetIconOverlay","x16","msSiteModeActivate","WebKitAgent","cancel","_currentId","_notifications","_agents","_configuration","payload","success","_removeNotification","desktop","isSupported","webkit","ms","unknown_interface","wrapper","_closeNotification","timeout","_addNotification","addEventListener","JSON","parse","event","action","Number","isInteger","_prepareNotification","create","e","sw","config","cb","_this3","_serviceWorkerCallback","chrome","firefox","fallback","onShow","onError","promiseCallback","invalid_title","has","reject","_createCallback","request","permission_denied","count","supported","agent","settings","manifest","plugin","hasProp","invalid_plugin","member","window","global"],"mappings":"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"}